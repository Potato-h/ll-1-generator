mod parser { # ! [allow (non_camel_case_types)] # ! [allow (non_upper_case_globals)] # ! [allow (dead_code)] # ! [allow (non_snake_case)] # ! [allow (unused_braces)] # ! [allow (unreachable_patterns)] use std :: fmt ; use lazy_static :: lazy_static ; use regex :: Regex ; pub struct ParserState <'input > { stream : &'input str , } impl <'input > ParserState <'input > { pub fn new (stream : &'input str) -> Self { ParserState { stream } } pub fn remainder (& self) -> &'input str { self . stream } pub fn push_spaces (& mut self) { self . stream = self . stream . trim_start () } pub fn is_prefix (& mut self , prefix : & str) -> bool { self . push_spaces () ; self . stream . starts_with (prefix) } pub fn is_prefix_re (& mut self , regex : & Regex) -> bool { self . push_spaces () ; regex . find (self . stream) . is_some_and (| m | m . start () == 0) } pub fn expect (& mut self , prefix : & str) -> Option <&'input str > { self . push_spaces () ; if self . stream . starts_with (prefix) { let res = Some (& self . stream [.. prefix . len ()]) ; self . bump (prefix . len ()) ; return res ; } else { None } } pub fn expect_re (& mut self , re : & Regex) -> Option <&'input str > { self . push_spaces () ; re . find (self . stream) . filter (| m | m . start () == 0) . map (| m | { let res = & self . stream [m . range ()] ; self . bump (m . len ()) ; res }) } pub fn bump (& mut self , bytes : usize) { self . stream = & self . stream [bytes ..] ; } } # [derive (Debug , Clone)] pub enum ParseError < T > { UnexpectedToken { actual : Option < T >, expected : T } , NoRuleFound (&'static str) , } impl < T : fmt :: Display > fmt :: Display for ParseError < T > { fn fmt (& self , f : & mut fmt :: Formatter <'_ >) -> fmt :: Result { match self { ParseError :: UnexpectedToken { actual , expected } => match actual { Some (actual) => { write ! (f , "Unexpected token: Expect {expected}, but found {actual}") } None => write ! (f , "Unexpected token: Expect {expected}, but found None") , } , ParseError :: NoRuleFound (state) => write ! (f , "while parsing {state}, found no rules") , } } } use super :: ast ; # [derive (Debug)] pub enum Token { Tok_6649517145671464817 , Tok_11300485392754115565 , Tok_4650208196263187980 , Tok_7744677365426763017 , Tok_12405958943024864307 , Tok_6898215271518772730 } impl fmt :: Display for Token { fn fmt (& self , f : & mut fmt :: Formatter < '_ >) -> fmt :: Result { match self { Token :: Tok_6649517145671464817 => write ! (f , ":") , Token :: Tok_11300485392754115565 => write ! (f , "(") , Token :: Tok_4650208196263187980 => write ! (f , ")") , Token :: Tok_7744677365426763017 => write ! (f , ",") , Token :: Tok_12405958943024864307 => write ! (f , "fun") , Token :: Tok_6898215271518772730 => write ! (f , "id") } } } lazy_static ! { static ref RE_Tok_6898215271518772730 : Regex = Regex :: new ("\\A[_a-zA-Z][_0-9a-zA-Z]*") . unwrap () ; } fn parse_Tok_6649517145671464817 < 'a > (parser : & mut ParserState < 'a >) -> Result < & 'a str , ParseError < Token >> { if let Some (res) = parser . expect (":") { Ok (res) } else { Err (ParseError :: UnexpectedToken { actual : parser . token () , expected : Token :: Tok_6649517145671464817 }) } } fn check_Tok_6649517145671464817 (parser : & mut ParserState) -> bool { parser . is_prefix (":") } fn parse_Tok_11300485392754115565 < 'a > (parser : & mut ParserState < 'a >) -> Result < & 'a str , ParseError < Token >> { if let Some (res) = parser . expect ("(") { Ok (res) } else { Err (ParseError :: UnexpectedToken { actual : parser . token () , expected : Token :: Tok_11300485392754115565 }) } } fn check_Tok_11300485392754115565 (parser : & mut ParserState) -> bool { parser . is_prefix ("(") } fn parse_Tok_4650208196263187980 < 'a > (parser : & mut ParserState < 'a >) -> Result < & 'a str , ParseError < Token >> { if let Some (res) = parser . expect (")") { Ok (res) } else { Err (ParseError :: UnexpectedToken { actual : parser . token () , expected : Token :: Tok_4650208196263187980 }) } } fn check_Tok_4650208196263187980 (parser : & mut ParserState) -> bool { parser . is_prefix (")") } fn parse_Tok_7744677365426763017 < 'a > (parser : & mut ParserState < 'a >) -> Result < & 'a str , ParseError < Token >> { if let Some (res) = parser . expect (",") { Ok (res) } else { Err (ParseError :: UnexpectedToken { actual : parser . token () , expected : Token :: Tok_7744677365426763017 }) } } fn check_Tok_7744677365426763017 (parser : & mut ParserState) -> bool { parser . is_prefix (",") } fn parse_Tok_12405958943024864307 < 'a > (parser : & mut ParserState < 'a >) -> Result < & 'a str , ParseError < Token >> { if let Some (res) = parser . expect ("fun") { Ok (res) } else { Err (ParseError :: UnexpectedToken { actual : parser . token () , expected : Token :: Tok_12405958943024864307 }) } } fn check_Tok_12405958943024864307 (parser : & mut ParserState) -> bool { parser . is_prefix ("fun") } fn parse_Tok_6898215271518772730 < 'a > (parser : & mut ParserState < 'a >) -> Result < & 'a str , ParseError < Token >> { if let Some (res) = parser . expect_re (& RE_Tok_6898215271518772730) { Ok (res) } else { Err (ParseError :: UnexpectedToken { actual : parser . token () , expected : Token :: Tok_6898215271518772730 }) } } fn check_Tok_6898215271518772730 (parser : & mut ParserState) -> bool { parser . is_prefix_re (& RE_Tok_6898215271518772730) } impl ParserState < '_ > { fn token (& mut self) -> Option < Token > { if check_Tok_6649517145671464817 (self) { return Some (Token :: Tok_6649517145671464817) } if check_Tok_11300485392754115565 (self) { return Some (Token :: Tok_11300485392754115565) } if check_Tok_4650208196263187980 (self) { return Some (Token :: Tok_4650208196263187980) } if check_Tok_7744677365426763017 (self) { return Some (Token :: Tok_7744677365426763017) } if check_Tok_12405958943024864307 (self) { return Some (Token :: Tok_12405958943024864307) } if check_Tok_6898215271518772730 (self) { return Some (Token :: Tok_6898215271518772730) } None } } fn parse_ty (parser : & mut ParserState ,) -> Result < ast :: Ty , ParseError < Token >> { match parser . token () { Some (Token :: Tok_6898215271518772730) => { let ty = parse_Tok_6898215271518772730 (parser) ? ; Ok ({ ast :: Ty (ty . to_owned ()) }) } , _ => Err (ParseError :: NoRuleFound ("ty")) , } } fn parse_ty_ann (parser : & mut ParserState ,) -> Result < ast :: Ty , ParseError < Token >> { match parser . token () { Some (Token :: Tok_6649517145671464817) => { let __ = parse_Tok_6649517145671464817 (parser) ? ; let ty = parse_ty (parser ,) ? ; Ok ({ ty }) } , _ => Err (ParseError :: NoRuleFound ("ty_ann")) , } } fn parse_arg (parser : & mut ParserState ,) -> Result < ast :: Arg , ParseError < Token >> { match parser . token () { Some (Token :: Tok_6898215271518772730) => { let name = parse_Tok_6898215271518772730 (parser) ? ; let ty = parse_ty_ann (parser ,) ? ; Ok ({ ast :: Arg { name : name . to_owned () , ty , } }) } , _ => Err (ParseError :: NoRuleFound ("arg")) , } } fn parse_args_cont (parser : & mut ParserState , mut args : Vec < ast :: Arg >) -> Result < Vec < ast :: Arg > , ParseError < Token >> { match parser . token () { Some (Token :: Tok_4650208196263187980) => { Ok ({ args }) } , Some (Token :: Tok_7744677365426763017) => { let __ = parse_Tok_7744677365426763017 (parser) ? ; let arg = parse_arg (parser ,) ? ; let cont = parse_args_cont (parser , { args . push (arg) ; args }) ? ; Ok ({ cont }) } , _ => Err (ParseError :: NoRuleFound ("args_cont")) , } } fn parse_args (parser : & mut ParserState ,) -> Result < Vec < ast :: Arg > , ParseError < Token >> { match parser . token () { Some (Token :: Tok_4650208196263187980) => { Ok ({ Vec :: new () }) } , Some (Token :: Tok_6898215271518772730) => { let arg = parse_arg (parser ,) ? ; let cont = parse_args_cont (parser , vec ! [arg]) ? ; Ok ({ cont }) } , _ => Err (ParseError :: NoRuleFound ("args")) , } } fn parse_ret_ty (parser : & mut ParserState ,) -> Result < Option < ast :: Ty > , ParseError < Token >> { match parser . token () { None => { Ok ({ None }) } , Some (Token :: Tok_6649517145671464817) => { let ty = parse_ty_ann (parser ,) ? ; Ok ({ Some (ty) }) } , _ => Err (ParseError :: NoRuleFound ("ret_ty")) , } } pub fn parse_sig (parser : & mut ParserState ,) -> Result < ast :: Signature , ParseError < Token >> { match parser . token () { Some (Token :: Tok_12405958943024864307) => { let __ = parse_Tok_12405958943024864307 (parser) ? ; let name = parse_Tok_6898215271518772730 (parser) ? ; let __ = parse_Tok_11300485392754115565 (parser) ? ; let args = parse_args (parser ,) ? ; let __ = parse_Tok_4650208196263187980 (parser) ? ; let ret_ty = parse_ret_ty (parser ,) ? ; Ok ({ ast :: Signature { name : name . to_string () , args , ret_ty , } }) } , _ => Err (ParseError :: NoRuleFound ("sig")) , } } }
