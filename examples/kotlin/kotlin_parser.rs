mod parser { # ! [allow (non_camel_case_types)] # ! [allow (non_upper_case_globals)] # ! [allow (dead_code)] # ! [allow (non_snake_case)] # ! [allow (unused_braces)] # ! [allow (unreachable_patterns)] use lazy_static :: lazy_static ; use regex :: Regex ; pub struct ParserState <'input > { stream : &'input str , } impl <'input > ParserState <'input > { pub fn new (stream : &'input str) -> Self { ParserState { stream } } pub fn remainder (& self) -> &'input str { self . stream } pub fn push_spaces (& mut self) { self . stream = self . stream . trim_start () } pub fn is_prefix (& mut self , prefix : & str) -> bool { self . push_spaces () ; self . stream . starts_with (prefix) } pub fn is_prefix_re (& mut self , regex : & Regex) -> bool { self . push_spaces () ; regex . find (self . stream) . is_some_and (| m | m . start () == 0) } pub fn expect (& mut self , prefix : & str) -> Option <&'input str > { self . push_spaces () ; if self . stream . starts_with (prefix) { let res = Some (& self . stream [.. prefix . len ()]) ; self . bump (prefix . len ()) ; return res ; } else { None } } pub fn expect_re (& mut self , re : & Regex) -> Option <&'input str > { self . push_spaces () ; re . find (self . stream) . filter (| m | m . start () == 0) . map (| m | { let res = & self . stream [m . range ()] ; self . bump (m . len ()) ; res }) } pub fn bump (& mut self , bytes : usize) { self . stream = & self . stream [bytes ..] ; } } use super :: ast ; enum Token { Tok_6649517145671464817 , Tok_11300485392754115565 , Tok_4650208196263187980 , Tok_7744677365426763017 , Tok_12405958943024864307 , Tok_6898215271518772730 } lazy_static ! { static ref RE_Tok_6898215271518772730 : Regex = Regex :: new ("\\A[_a-zA-Z][_0-9a-zA-Z]*") . unwrap () ; } fn parse_Tok_6649517145671464817 < 'a > (parser : & mut ParserState < 'a >) -> Option < & 'a str > { parser . expect (":") } fn check_Tok_6649517145671464817 (parser : & mut ParserState) -> bool { parser . is_prefix (":") } fn parse_Tok_11300485392754115565 < 'a > (parser : & mut ParserState < 'a >) -> Option < & 'a str > { parser . expect ("(") } fn check_Tok_11300485392754115565 (parser : & mut ParserState) -> bool { parser . is_prefix ("(") } fn parse_Tok_4650208196263187980 < 'a > (parser : & mut ParserState < 'a >) -> Option < & 'a str > { parser . expect (")") } fn check_Tok_4650208196263187980 (parser : & mut ParserState) -> bool { parser . is_prefix (")") } fn parse_Tok_7744677365426763017 < 'a > (parser : & mut ParserState < 'a >) -> Option < & 'a str > { parser . expect (",") } fn check_Tok_7744677365426763017 (parser : & mut ParserState) -> bool { parser . is_prefix (",") } fn parse_Tok_12405958943024864307 < 'a > (parser : & mut ParserState < 'a >) -> Option < & 'a str > { parser . expect ("fun") } fn check_Tok_12405958943024864307 (parser : & mut ParserState) -> bool { parser . is_prefix ("fun") } fn parse_Tok_6898215271518772730 < 'a > (parser : & mut ParserState < 'a >) -> Option < & 'a str > { parser . expect_re (& RE_Tok_6898215271518772730) } fn check_Tok_6898215271518772730 (parser : & mut ParserState) -> bool { parser . is_prefix_re (& RE_Tok_6898215271518772730) } impl ParserState < '_ > { fn token (& mut self) -> Option < Token > { if check_Tok_6649517145671464817 (self) { return Some (Token :: Tok_6649517145671464817) } if check_Tok_11300485392754115565 (self) { return Some (Token :: Tok_11300485392754115565) } if check_Tok_4650208196263187980 (self) { return Some (Token :: Tok_4650208196263187980) } if check_Tok_7744677365426763017 (self) { return Some (Token :: Tok_7744677365426763017) } if check_Tok_12405958943024864307 (self) { return Some (Token :: Tok_12405958943024864307) } if check_Tok_6898215271518772730 (self) { return Some (Token :: Tok_6898215271518772730) } None } } fn parse_ty (parser : & mut ParserState ,) -> Option < ast :: Ty > { match parser . token () { Some (Token :: Tok_6898215271518772730) => { let ty = parse_Tok_6898215271518772730 (parser) ? ; Some ({ ast :: Ty (ty . to_owned ()) }) } , _ => None , } } fn parse_ty_ann (parser : & mut ParserState ,) -> Option < ast :: Ty > { match parser . token () { Some (Token :: Tok_6649517145671464817) => { let __ = parse_Tok_6649517145671464817 (parser) ? ; let ty = parse_ty (parser ,) ? ; Some ({ ty }) } , _ => None , } } fn parse_arg (parser : & mut ParserState ,) -> Option < ast :: Arg > { match parser . token () { Some (Token :: Tok_6898215271518772730) => { let name = parse_Tok_6898215271518772730 (parser) ? ; let ty = parse_ty_ann (parser ,) ? ; Some ({ ast :: Arg { name : name . to_owned () , ty , } }) } , _ => None , } } fn parse_args_cont (parser : & mut ParserState , mut args : Vec < ast :: Arg >) -> Option < Vec < ast :: Arg > > { match parser . token () { Some (Token :: Tok_4650208196263187980) => { Some ({ args }) } , Some (Token :: Tok_7744677365426763017) => { let __ = parse_Tok_7744677365426763017 (parser) ? ; let arg = parse_arg (parser ,) ? ; let cont = parse_args_cont (parser , { args . push (arg) ; args }) ? ; Some ({ cont }) } , _ => None , } } fn parse_args (parser : & mut ParserState ,) -> Option < Vec < ast :: Arg > > { match parser . token () { Some (Token :: Tok_4650208196263187980) => { Some ({ Vec :: new () }) } , Some (Token :: Tok_6898215271518772730) => { let arg = parse_arg (parser ,) ? ; let cont = parse_args_cont (parser , vec ! [arg]) ? ; Some ({ cont }) } , _ => None , } } fn parse_ret_ty (parser : & mut ParserState ,) -> Option < Option < ast :: Ty > > { match parser . token () { None => { Some ({ None }) } , Some (Token :: Tok_6649517145671464817) => { let ty = parse_ty_ann (parser ,) ? ; Some ({ Some (ty) }) } , _ => None , } } pub fn parse_sig (parser : & mut ParserState ,) -> Option < ast :: Signature > { match parser . token () { Some (Token :: Tok_12405958943024864307) => { let __ = parse_Tok_12405958943024864307 (parser) ? ; let name = parse_Tok_6898215271518772730 (parser) ? ; let __ = parse_Tok_11300485392754115565 (parser) ? ; let args = parse_args (parser ,) ? ; let __ = parse_Tok_4650208196263187980 (parser) ? ; let ret_ty = parse_ret_ty (parser ,) ? ; Some ({ ast :: Signature { name : name . to_string () , args , ret_ty , } }) } , _ => None , } } }
